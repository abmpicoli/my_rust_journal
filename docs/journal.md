# Learning journal. 

https://doc.rust-lang.org/book/ch01-02-hello-world.html 

Sept/23/2023
------------

* `rustc` is the compiler that generates a ready to run output.
  
  it generates an executable that you can use to run the code. Automatic linker.

* `println!` is a macro.

  Rust doesn't accept functions with variable arguments.
 
  A macro can be used to parse variable arguments, either by invoking a function
  or by parsing the variable arguments itself?

  > BABY STEPS: look into it later.

* `cargo new hello_cargo` to create a new project.

* cargo has a lot of options, and a special search system `cargo search` 

Sept/29/2023 06:41
------------------

https://doc.rust-lang.org/book/ch01-03-hello-cargo.html

* `cargo build` to build the project. It will got to the target dir.

* `cargo build --release` to build the project in "release mode".

> Não achei nenhuma diferença entre o executável em modo build e o em modo release. Mesmo tamanho e tals.

O executável fica no target/release

O target/debug tem o que constroi com `cargo build`

`Cargo.toml` is where the package definition is.

> Parece um package.json do nodeJS

> E o Cargo.lock "parece ser a mesma coisa, mas não é.": 

> Cargo.toml = dependencia flutuante: github repo X. 

> Cargo.lock = dependência fixa gerada no build.
UPDATE 03/Oct/2023: - e lock significa "locked mesmo": a dependência fica 
parada no tempo até quando você der um `cargo update`

### Cargo.toml
```
[package]
name = "learning_rust"
version = "0.1.0"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
regex = { git = "https://github.com/rust-lang/regex.git" }
```

### Cargo.lock 

Gerado depois que meti um cargo build no bixo.

```
# This file is automatically @generated by Cargo.
# It is not intended for manual editing.
version = 3

...
[[package]]
name = "aho-corasick"
version = "1.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ea5d730647d4fadd988536d06fecce94b7b4f2a7efdae548f1cf4b63205518ab"
dependencies = [
 "memchr",
]

[[package]]
name = "regex"
version = "1.9.5"
source = "git+https://github.com/rust-lang/regex.git#27a25385c0bd1228716271668febc88bd8c74932"
dependencies = [
 "aho-corasick",
 "memchr",
 "regex-automata",
 "regex-syntax",
]

...
```

> O Cargo é poderoso pra cacete: dá pra referenciar multiplos registros, e tem um Cargo.rs pra rodar um "rust script" que constroi coisas maus complexas.

https://doc.rust-lang.org/cargo/guide/index.html 

O ".toml" é na verdade uma especificação tipo yaml : https://toml.io/en/ 

Sept/29/2023 08:19
------------------

https://doc.rust-lang.org/book/ch02-00-guessing-game-tutorial.html

> At a "beginner" level, rust is not quite different than C (not C++. C) . The difference is Cargo, that is there to help you packaging (which is a very welcome 
improvement over the more esoteric failure prone makefile systems we typically see for projects in the C language).

Not needing to worry about a makefile to make a reliable build is very welcome, indeed.

> QUESTION: What about that `edition = "2021"` inside the Cargo.toml file? I've just ran rustup update and I'm already using rust from 2023...
>
> ANSWER: edition can be thought about an "specification format". edition says the Cargo file is using a format for 2021: it was not changed in 2023, so they are keeping it
> as it is.

> QUESTION: Just created a main.rs file. And cargo doesn't seems to recognize it. 
> ANSWER: MIND THE FILE TIMESTAMPS. If the file is older than the binary, it won't recompile it. (DUH).

> Macro calls needs those `{ }` things! `println! "Hello world"` will fail. 

```
abpicoli@DESKTOP-EPFPMPH:/mnt/e/projetos/my_rust_journal/chapter3_guessing_game$ cargo run
   Compiling chapter3_guessing_game v0.1.0 (/mnt/e/projetos/my_rust_journal/chapter3_guessing_game)
error: expected one of `(`, `[`, or `{`, found `"Hello chapter 3"`
 --> src/main.rs:3:14
  |
3 |     println! "Hello chapter 3";
  |              ^^^^^^^^^^^^^^^^^ expected one of `(`, `[`, or `{`

```
SOLUTION:

```
fn main() {

    println! {"Hello chapter 3"} ;

}
```

> Question: What is the difference between '(' , '[' or '{' when invoking a macro??
> 
> Answer: (hypothesis) : because a macro can be invoked over multiple object types: single stuff ("x"). vector stuff ["x"] or tuple stuff? {"x"}? 

https://doc.rust-lang.org/reference/macros.html


Sept/30/2023 09:46
------------------

Initial evaluation: Can we use Saxon from RUST?

One of the demands of my work is xml processing. Our solution is based from the end user perspective 
(that is, someone developing an integration using the java framework we have) is a typical web-app 
configuration (web.xml) that takes a properties file that contains specifications of a sequence of "processors"
to be invoked. 

The glue specifying the order between processors and the data used is XML, specifically through XSL processing XML data.

So, if this platform is to be ported in some way to rust, without causing extensive re-learning of another language than
the typical XSLT the end users are accustomed to, Rust must have something that supports XSLT. Preferably version 2 or 3.

The only tool in the market I know to support that is Saxonica's Saxon 12.

All xml libraries I've seen of rust are very incipient, not even supporting XSLT. 

And I've discovered that Saxon doesn't support Rust. 

Well. Rust supports C calls (grudgingly, dare I say?) and Saxon supports C programs. So maybe 


https://www.saxonica.com/saxon-c/documentation12/index.html#!samples/samples_c 
this can be done eventually.

I'm not too worried about environment compatibilities now because the solutions tend to be run from inside a docker environment,
with a fixed Ubuntu OS. 

WELL::: BABY STEPS !

Resuming https://doc.rust-lang.org/book/ch02-00-guessing-game-tutorial.html 

I've created the project inside 'chapter3_guessing_game' directory. And the insights I have are in multiple commits in code comments in the main.rs

Oct/1/2023 09:51
----------------

### rust use  ~= java import
In the last day, I did discover that what in java we call "packages" and the "import" directive are not that different (in a very first level view, mind that)

`use std::io` is not unlike `import java.io.*` in java. In the sense it is only an abbreviation of a dependency involving
methods that may be invoked without a full package reference.

`use std::io ... stdin.read` 

is equivalent to `std::io::stdin.read` 

like with java `import java.io ... InputStream i ` 

is the equivalent of `java.io.InputStream i`

### rust is not object oriented. Not in first view.

In java, even a main class is a class. the pattern is `class X { public static void main(String... args) { ... } `. Classes have constructors with specific 
invocations.

In rust, what we have are conventions: `let mut x = String::new` is not the same thing as `StringBuilder x = new StringBuilder()`.

For starters:

* the `new` in the rust code is a *convention*. I could call the constructor whatever I want. the new is only a method name commonly used to instantiate new instances.

### BIG BIG BIG difference between java and rust!

In rust, libraries are provided for common functions, so in a sense there is an "equivalent"
of the java standard API. And the java API is **HUGE**. java.io, java.util, java.text. java.sql ... And *EVERYTHING* is packaged as a single release. Java 1.8, java 9, java 10.

And for java, a java runtime must comes with every single package there as part of 
the package.

Not so with rust, it seems:

IN java, want to use the random generator? Just invoke 
```
import java.util.Random 

...

public static void main(String... args) {
	Random x = new Random();
	x = Random.nextInt();
}
```

In rust, even something as trivial as random number generation is out, and it
must be specified in the cargo.toml.

Well... rust  is not unlike C, in this aspect right? To use rand we need to
`#include <stdlib.h>`... But YES, it is different! Because the stdlib reference
is *FLOATING*: it is a reference to whatever is installed into your own computer.

Like java. Or python with that PIP install thing (at least at first view. Not a python expert).

In rust, I must specify a library *and a version* . In the cargo.toml:

```
[dependencies]
rand = "0.8.5"
```

And only then can I use it inside the code.


UPDATE: When I've tried to simply qualify the reference to the code from inside the code, I've just discovered that rust crates are crazy!!!

If you have a code like 

```use rand::Rng

       let secret_number = rand::thread_rng().gen_range(1..=100);

```

Obviously I could use the full reference package, like, ignore the rand::Rng 

and do something like this... Right? RIGHT?? WRONG!

```
    let secret_number = rand::Rng::rand::thread_rng().gen_range(1..=100);
```

error[E0223]: ambiguous associated type
  --> src/main.rs:13:25
   |
13 |     let secret_number = <dyn rand::Rng>::rand::thread_rng().gen_range(1..=100);
   |                         ^^^^^^^^^^^^^^^^^^^^^
   |
help: if there were a trait named `Example` with associated type `rand` implemented for `dyn Rng`, you could use the fully-qualified path

THERE IS MUCH MORE TO rust crates than only the java equivalent of "packaged classes"... Baby steps. More to come.

https://doc.rust-lang.org/book/ch02-00-guessing-game-tutorial.html#generating-a-random-number 

03/Oct/2023
-----------

The more I look into it, the more I see that there is a big concern about packaging and documentation when publishing crates (which would be traditional java jars).

The use directive mention a crate and then something inside the crate.

"Remember that a crate is a collection of Rust source code files. " : se não tem uma distribuição binária, taí porque o build seria lento.

If you look into the target directory, there is a debug/deps directory, that contains a reference to your local registry: /home/abpicoli/.cargo/registry/

E:\projetos\my_rust_journal\chapter3_guessing_game\target\debug\deps\cfg_if-52fc72e823305762.rmeta: C:\Users\Usuario\.cargo\registry\src\index.crates.io-6f17d22bba15001f\cfg-if-1.0.0\src\lib.rs

E:\projetos\my_rust_journal\chapter3_guessing_game\target\debug\deps\cfg_if-52fc72e823305762.d: C:\Users\Usuario\.cargo\registry\src\index.crates.io-6f17d22bba15001f\cfg-if-1.0.0\src\lib.rs

C:\Users\Usuario\.cargo\registry\src\index.crates.io-6f17d22bba15001f\cfg-if-1.0.0\src\lib.rs:


### A CRATE IS A SOURCE-CODE DISTRIBUTION!!! COMPLETELY DIFFERENT FROM JAVA AND THEIR MAVEN COUNTERPARTS!!


### Shadowing: 

In java, you specify the type and the variable with that name has that type, forever, in the scope of the application.

In rust, you may have multiple versions of the same variable, with different types. 

And the correct type is used depending on the context??? No, right? It seems the type is "shadowed" into a new type?

Yes, this is what happens: guess becomes a u32 variable through the rest of the code.

let mut guess = String::new();
...
let guess: u32 = guess.trim().parse().expect("Please type a number!")

### Match:

match is a switch for enumerations.

But it is more... For example, the parse() method has an Ok(number) as an option, or an Err(error message) as other option, so you must specify the content, and can use the 
parameter as useful information on responding to each case.

```
	let guess: u32 = match guess.trim().parse() {
		Ok(num) => num, //just return the input number
		Err(err) => {
			println!("Bad number ! {err} {guess}"); // err =  the error message when parsing the input...
			continue;
		}
	};
```