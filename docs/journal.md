# Learning journal. 

https://doc.rust-lang.org/book/ch01-02-hello-world.html 

Sept/23/2023
------------

* `rustc` is the compiler that generates a ready to run output.
  
  it generates an executable that you can use to run the code. Automatic linker.

* `println!` is a macro.

  Rust doesn't accept functions with variable arguments.
 
  A macro can be used to parse variable arguments, either by invoking a function
  or by parsing the variable arguments itself?

  > BABY STEPS: look into it later.

* `cargo new hello_cargo` to create a new project.

* cargo has a lot of options, and a special search system `cargo search` 

Sept/29/2023 06:41
------------------

https://doc.rust-lang.org/book/ch01-03-hello-cargo.html

* `cargo build` to build the project. It will got to the target dir.

* `cargo build --release` to build the project in "release mode".

> Não achei nenhuma diferença entre o executável em modo build e o em modo release. Mesmo tamanho e tals.

O executável fica no target/release

O target/debug tem o que constroi com `cargo build`

`Cargo.toml` is where the package definition is.

> Parece um package.json do nodeJS

> E o Cargo.lock "parece ser a mesma coisa, mas não é.": 

> Cargo.toml = dependencia flutuante: github repo X. 

> Cargo.lock = dependência fixa gerada no build.

### Cargo.toml
```
[package]
name = "learning_rust"
version = "0.1.0"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
regex = { git = "https://github.com/rust-lang/regex.git" }
```

### Cargo.lock 

Gerado depois que meti um cargo build no bixo.

```
# This file is automatically @generated by Cargo.
# It is not intended for manual editing.
version = 3

...
[[package]]
name = "aho-corasick"
version = "1.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ea5d730647d4fadd988536d06fecce94b7b4f2a7efdae548f1cf4b63205518ab"
dependencies = [
 "memchr",
]

[[package]]
name = "regex"
version = "1.9.5"
source = "git+https://github.com/rust-lang/regex.git#27a25385c0bd1228716271668febc88bd8c74932"
dependencies = [
 "aho-corasick",
 "memchr",
 "regex-automata",
 "regex-syntax",
]

...
```

> O Cargo é poderoso pra cacete: dá pra referenciar multiplos registros, e tem um Cargo.rs pra rodar um "rust script" que constroi coisas maus complexas.

https://doc.rust-lang.org/cargo/guide/index.html 

O ".toml" é na verdade uma especificação tipo yaml : https://toml.io/en/ 

Sept/29/2023 08:19
------------------

https://doc.rust-lang.org/book/ch02-00-guessing-game-tutorial.html

> At a "beginner" level, rust is not quite different than C (not C++. C) . The difference is Cargo, that is there to help you packaging (which is a very welcome 
improvement over the more esoteric failure prone makefile systems we typically see for projects in the C language).

Not needing to worry about a makefile to make a reliable build is very welcome, indeed.

> QUESTION: What about that `edition = "2021"` inside the Cargo.toml file? I've just ran rustup update and I'm already using rust from 2023...
>
> ANSWER: edition can be thought about an "specification format". edition says the Cargo file is using a format for 2021: it was not changed in 2023, so they are keeping it
> as it is.

> QUESTION: Just created a main.rs file. And cargo doesn't seems to recognize it. 
> ANSWER: MIND THE FILE TIMESTAMPS. If the file is older than the binary, it won't recompile it. (DUH).

> Macro calls needs those `{ }` things! `println! "Hello world"` will fail. 

```
abpicoli@DESKTOP-EPFPMPH:/mnt/e/projetos/my_rust_journal/chapter3_guessing_game$ cargo run
   Compiling chapter3_guessing_game v0.1.0 (/mnt/e/projetos/my_rust_journal/chapter3_guessing_game)
error: expected one of `(`, `[`, or `{`, found `"Hello chapter 3"`
 --> src/main.rs:3:14
  |
3 |     println! "Hello chapter 3";
  |              ^^^^^^^^^^^^^^^^^ expected one of `(`, `[`, or `{`

```
SOLUTION:

```
fn main() {

    println! {"Hello chapter 3"} ;

}
```

> Question: What is the difference between '(' , '[' or '{' when invoking a macro??
> 
> Answer: (hypothesis) : because a macro can be invoked over multiple object types: single stuff ("x"). vector stuff ["x"] or tuple stuff? {"x"}? 

https://doc.rust-lang.org/reference/macros.html


Sept/30/2023 09:46
------------------

Initial evaluation: Can we use Saxon from RUST?

One of the demands of my work is xml processing. Our solution is based from the end user perspective 
(that is, someone developing an integration using the java framework we have) is a typical web-app 
configuration (web.xml) that takes a properties file that contains specifications of a sequence of "processors"
to be invoked. 

The glue specifying the order between processors and the data used is XML, specifically through XSL processing XML data.

So, if this platform is to be ported in some way to rust, without causing extensive re-learning of another language than
the typical XSLT the end users are accustomed to, Rust must have something that supports XSLT. Preferably version 2 or 3.

The only tool in the market I know to support that is Saxonica's Saxon 12.

All xml libraries I've seen of rust are very incipient, not even supporting XSLT. 

And I've discovered that Saxon doesn't support Rust. 

Well. Rust supports C calls (grudgingly, dare I say?) and Saxon supports C programs. So maybe 


https://www.saxonica.com/saxon-c/documentation12/index.html#!samples/samples_c 
this can be done eventually.

I'm not too worried about environment compatibilities now because the solutions tend to be run from inside a docker environment,
with a fixed Ubuntu OS. 

WELL::: BABY STEPS !

Resuming https://doc.rust-lang.org/book/ch02-00-guessing-game-tutorial.html 

I've created the project inside 'chapter3_guessing_game' directory.



